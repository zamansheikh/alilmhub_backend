import { model, Schema, Types } from "mongoose";
import { 
  ITopicDocument, 
  TopicModel, 
  TBreadcrumb, 
  TSpan, 
  TContentUnit, 
  TContentBlock, 
  TContentChange, 
  TVersion 
} from "./topic.interface";

// ============================================================================
// SUB-SCHEMAS
// ============================================================================

const spanSchema = new Schema<TSpan>(
  {
    text: { type: String, required: true },
    type: {
      type: String,
      enum: ["text", "reference", "debate"],
      required: true,
    },
    marks: [{ type: String }],
    data: {
      refId: String,
      debateId: String,
      stance: {
        type: String,
        enum: ["supporting", "opposing", "neutral"],
      },
    },
  },
  { _id: false }
);

const contentUnitSchema = new Schema<TContentUnit>(
  {
    id: { type: String, required: true },
    content: { type: String, required: true },
    spans: [spanSchema],
  },
  { _id: false }
);

const contentBlockSchema = new Schema<TContentBlock>(
  {
    id: { type: String, required: true },
    type: {
      type: String,
      enum: ["heading", "paragraph", "list", "quote", "code"],
      required: true,
    },
    units: [contentUnitSchema],
    metadata: {
      level: Number,
      ordered: Boolean,
      language: String,
    },
  },
  { _id: false }
);

const contentChangeSchema = new Schema<TContentChange>(
  {
    blockId: { type: String, required: true },
    unitId: { type: String, required: false },
    spanIndex: { type: Number, required: false },
    oldText: { type: String, required: true },
    newText: { type: String, required: true },
    diff: { type: String, required: true },
  },
  { _id: false }
);

const versionSchema = new Schema<TVersion>(
  {
    versionId: { type: String, required: true },
    changedAt: { type: Date, required: true },
    changedBy: { type: Schema.Types.ObjectId, ref: "User", required: true },
    changes: [contentChangeSchema],
    contentBlocks: [contentBlockSchema],
    wikiContent: { type: String },
    status: {
      type: String,
      enum: ["pending", "approved", "rejected"],
      default: "pending",
    },
    reviewedAt: { type: Date },
    reviewedBy: { type: Schema.Types.ObjectId, ref: "User" },
    reviewNote: { type: String },
  },
  { _id: false }
);

// ============================================================================
// MAIN TOPIC SCHEMA
// ============================================================================

const topicSchema = new Schema<ITopicDocument>(
  {
    // ===== IDENTIFICATION =====
    // Three identifier fields exist for different purposes:
    // - _id: MongoDB's internal ObjectId (auto-generated, immutable)
    // - slug: Human-readable URL identifier (auto-generated or custom, immutable after creation)
    // - id: Custom semantic identifier (auto-generated from title, immutable after creation)
    // 
    // Usage guidelines:
    // - Use 'slug' for public-facing URLs and routing
    // - Use 'id' for internal relationships and business logic
    // - Use '_id' only for legacy MongoDB operations
    id: {
      type: String,
      required: false, // Will be auto-generated
      unique: true,
      sparse: true,
      trim: true,
    },
    slug: {
      type: String,
      required: false, // Auto-generated by pre-save middleware
      trim: true,
      unique: true,
    },
    title: {
      type: String,
      required: true,
      trim: true,
    },

    // ===== HIERARCHY (MATERIALIZED PATH) =====
    parentId: {
      type: String,
      ref: "Topic",
    },
    level: {
      type: Number,
      required: true,
      default: 0,
    },
    path: {
      type: String,
      required: true,
      default: "/",
      trim: true,
    },

    // ===== CONTENT =====
    summary: {
      type: String,
      required: false, // Made optional for migration
      default: "",
      trim: true,
    },
    titleDescription: {
      type: String,
      trim: true,
    },
    wikiContent: {
      type: String,
      required: false, // Made optional for migration
      default: "",
    },

    // ===== VERSIONED CONTENT =====
    versions: {
      type: [versionSchema],
      default: [],
    },
    contentBlocks: {
      type: [contentBlockSchema],
      required: false, // Made optional for migration
      default: [],
    },

    // ===== STATUS & WORKFLOW =====
    status: {
      type: String,
      enum: ["draft", "published", "archived"],
      default: "published",
    },
    canonical: {
      type: Boolean,
      default: true,
    },

    // ===== RELATIONSHIPS =====
    references: {
      type: [String],
      default: [],
    },
    debates: {
      type: [String],
      default: [],
    },
    discussions: {
      type: [String],
      default: [],
    },

    // ===== LEGACY FIELDS (BACKWARD COMPATIBILITY) =====
    parentTopic: {
      type: Schema.Types.ObjectId,
      ref: "Topic",
    },
    editsCount: {
      type: Number,
      default: 0,
    },
    viewsCount: {
      type: Number,
      default: 0,
    },

    // ===== METADATA =====
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    updatedBy: {
      type: Schema.Types.ObjectId,
      ref: "User",
    },
    viewCount: {
      type: Number,
      default: 0,
    },
    editCount: {
      type: Number,
      default: 0,
    },
    isFeatured: {
      type: Boolean,
      default: false,
    },
    isDeleted: {
      type: Boolean,
      default: false,
    },
  },
  {
    timestamps: true,
    versionKey: false,
  }
);

// ============================================================================
// INDEXES
// ============================================================================

// Legacy indexes
topicSchema.index({ title: 1 });
topicSchema.index({ parentTopic: 1 });
topicSchema.index({ isDeleted: 1 });
topicSchema.index({ createdAt: -1 });

// New indexes for scalability
topicSchema.index({ id: 1 }, { unique: true, sparse: true });
topicSchema.index({ slug: 1 }, { unique: true });
topicSchema.index({ parentId: 1 });
topicSchema.index({ path: 1 });
topicSchema.index({ status: 1, canonical: 1 });
topicSchema.index({ references: 1 });
topicSchema.index({ debates: 1 });
topicSchema.index({ viewCount: -1 });
topicSchema.index({ updatedAt: -1 });

// Compound indexes
topicSchema.index({ path: 1, status: 1 });
topicSchema.index({ level: 1, viewCount: -1 });

// Text search
topicSchema.index({ title: "text", summary: "text", wikiContent: "text" });

// ============================================================================
// MIDDLEWARE
// ============================================================================

topicSchema.pre("save", async function (next) {
  // Step 0: Prevent slug modification on existing documents
  if (!this.isNew && this.isModified("slug")) {
    throw new Error(
      "Slug cannot be modified after creation. " +
      "Changing slug would break paths of all child topics. " +
      "If you need to change the URL, create a redirect instead."
    );
  }

  // Step 1: Auto-generate slug if not provided (SEO-friendly from title)
  if (!this.slug && this.isNew) {
    // Generate base slug from title: "Salah (Islamic Prayer)" → "salah-islamic-prayer"
    let baseSlug = this.title
      .toLowerCase()
      .trim()
      .replace(/[^\w\s-]/g, '')      // Remove special characters
      .replace(/\s+/g, '-')           // Replace spaces with hyphens
      .replace(/-+/g, '-')            // Multiple hyphens to single
      .replace(/^-|-$/g, '')          // Trim hyphens from edges
      .substring(0, 60);              // Limit length
    
    // Ensure uniqueness with database check
    this.slug = baseSlug;
    let counter = 1;
    const maxRetries = 100;  // Handle up to 100 duplicates
    
    while (counter < maxRetries) {
      const exists = await Topic.findOne({ slug: this.slug }).select('_id').lean();
      if (!exists) break;  // Unique slug found!
      
      // Collision detected, append counter
      this.slug = `${baseSlug}-${counter}`;
      counter++;
    }
    
    // Fallback: if all counters exhausted, use timestamp for guaranteed uniqueness
    if (counter >= maxRetries) {
      this.slug = `${baseSlug}-${Date.now()}`;
    }
  }

  // Step 2: Auto-generate custom ID if not provided (with uniqueness check)
  if (!this.id && this.isNew) {
    // Create ID from title: "Salah (Prayer)" → "topic_salah_prayer"
    let slugified = this.title
      .toLowerCase()
      .replace(/[^\w\s-]/g, "")
      .replace(/\s+/g, "_")
      .substring(0, 50);
    
    // Add timestamp suffix to reduce collision chance
    const shortTimestamp = Date.now().toString().slice(-6);
    let customId = `topic_${slugified}_${shortTimestamp}`;
    
    // Ensure uniqueness with limited retries
    let counter = 1;
    const maxRetries = 5;
    while (counter < maxRetries) {
      const existing = await Topic.findOne({ id: customId }).lean();
      if (!existing) break;
      customId = `topic_${slugified}_${shortTimestamp}_${counter}`;
      counter++;
    }
    
    this.id = customId;
  }

  // Step 3: Calculate path and check for circular references
  // NOTE: Slug is immutable after creation (enforced in Step 0)
  // However, parentId can change, which requires path recalculation
  if (this.isNew || this.isModified("parentId")) {
    if (this.parentId) {
      // Check for circular reference (self-referencing)
      if (this.id && this.parentId === this.id) {
        throw new Error("A topic cannot be its own parent");
      }
      
      const parent = await Topic.findOne({ 
        $or: [
          { id: this.parentId },
          { slug: this.parentId }
        ],
        isDeleted: { $ne: true } 
      });
      if (!parent) {
        // FIXED: Throw error instead of silently making it root
        throw new Error(`Parent topic with id or slug "${this.parentId}" not found or has been deleted`);
      }
      
      // Ensure we use the actual ID, not the slug, for the parentId field
      this.parentId = parent.id;
      
      // Check if current topic is an ancestor of the new parent
      // This prevents circular hierarchies (A → B → C → A)
      if (!this.isNew && this.slug) {
        // For existing topics, check if parent path includes our slug
        const pathSegments = parent.path.split('/').filter(Boolean);
        if (pathSegments.includes(this.slug)) {
          throw new Error("Circular reference detected: Cannot set a descendant as parent");
        }
      }
      
      // FIXED: Ensure slug is set before using it in path
      if (!this.slug) {
        throw new Error("Slug must be generated before calculating path");
      }
      
      this.path = `${parent.path}/${this.slug}`;
      this.level = parent.level + 1;
      
      // Sync legacy field for backward compatibility
      if (parent._id) {
        this.parentTopic = parent._id as Types.ObjectId;
      }
    } else {
      // No parent - this is a root topic
      if (!this.slug) {
        throw new Error("Slug must be generated before calculating path");
      }
      this.path = `/${this.slug}`;
      this.level = 0;
      this.parentTopic = undefined;
    }
  }

  // Step 4: Sync legacy fields
  this.viewsCount = this.viewCount;
  this.editsCount = this.editCount;

  // Step 5: Extract references and debates from contentBlocks
  if (this.contentBlocks && this.contentBlocks.length > 0) {
    const refIds = new Set<string>();
    const debateIds = new Set<string>();

    this.contentBlocks.forEach((block: TContentBlock) => {
      block.units.forEach((unit) => {
        unit.spans.forEach((span) => {
          if (span.type === "reference" && span.data?.refId) {
            refIds.add(span.data.refId);
          }
          if (span.type === "debate" && span.data?.debateId) {
            debateIds.add(span.data.debateId);
          }
        });
      });
    });

    this.references = Array.from(refIds);
    this.debates = Array.from(debateIds);
  }

  next();
});

// ============================================================================
// INSTANCE METHODS
// ============================================================================

/**
 * Get breadcrumb navigation
 * NEW: O(1) with materialized path - just split and query once!
 * OLD: O(n) with recursive queries
 */
topicSchema.methods.getBreadcrumb = async function (): Promise<TBreadcrumb[]> {
  // Use new path-based approach if available
  if (this.path && this.path !== "/") {
    const slugs = this.path.split("/").filter(Boolean);
    const topics = await Topic.find({ slug: { $in: slugs } }).select("slug title");
    
    return slugs.map((slug: string) => {
      const topic = topics.find((t) => t.slug === slug);
      return {
        slug: topic?.slug || slug,
        title: topic?.title || slug,
      };
    });
  }

  // Fallback to legacy recursive approach
  const breadcrumbs: TBreadcrumb[] = [];
  // eslint-disable-next-line @typescript-eslint/no-this-alias
  let currentTopic: any = this;

  while (currentTopic) {
    breadcrumbs.unshift({
      slug: currentTopic.slug,
      title: currentTopic.title,
    });

    if (currentTopic.parentTopic) {
      currentTopic = await Topic.findById(currentTopic.parentTopic);
    } else {
      currentTopic = null;
    }
  }

  return breadcrumbs;
};

/**
 * Get a specific version
 */
topicSchema.methods.getVersion = function (versionId: string) {
  return this.versions.find((v: TVersion) => v.versionId === versionId) || null;
};

/**
 * Create a new version
 */
topicSchema.methods.createNewVersion = async function (
  userId: Types.ObjectId,
  changes: TContentChange[],
  newContent: TContentBlock[],
  wikiContent?: string
) {
  const nextVersionNumber = this.versions.length + 1;
  const newVersion: TVersion = {
    versionId: `v${nextVersionNumber}`,
    changedAt: new Date(),
    changedBy: userId,
    changes: changes,
    contentBlocks: newContent,
    wikiContent: wikiContent,
    status: "pending",
  };

  this.versions.push(newVersion);
  // NOTE: do NOT overwrite live contentBlocks / wikiContent here.
  // The live content is only updated when the version is *approved*
  // (see reviewTopicVersion in topic.service.ts).
  this.updatedBy = userId;
  this.editCount = this.versions.length - 1;
  this.editsCount = this.editCount;

  await this.save();
};

/**
 * Extract all reference IDs from content
 */
topicSchema.methods.extractReferences = function (
  blocks: TContentBlock[]
): string[] {
  const refIds = new Set<string>();

  blocks.forEach((block) => {
    block.units.forEach((unit) => {
      unit.spans.forEach((span) => {
        if (span.type === "reference" && span.data?.refId) {
          refIds.add(span.data.refId);
        }
      });
    });
  });

  return Array.from(refIds);
};

/**
 * Extract all debate IDs from content
 */
topicSchema.methods.extractDebates = function (
  blocks: TContentBlock[]
): string[] {
  const debateIds = new Set<string>();

  blocks.forEach((block) => {
    block.units.forEach((unit) => {
      unit.spans.forEach((span) => {
        if (span.type === "debate" && span.data?.debateId) {
          debateIds.add(span.data.debateId);
        }
      });
    });
  });

  return Array.from(debateIds);
};

// ============================================================================
// STATIC METHODS
// ============================================================================

topicSchema.statics.isExistBySlug = async function (slug: string) {
  return this.findOne({ slug });
};

topicSchema.statics.isExistById = async function (id: string) {
  return this.findOne({ id });
};

topicSchema.statics.getBreadcrumbPath = async function (
  topicId: Types.ObjectId
): Promise<TBreadcrumb[]> {
  const topic = await this.findById(topicId);
  if (!topic) return [];
  return topic.getBreadcrumb();
};

/**
 * Get all children of a topic
 * NEW: Single query with parentId
 */
topicSchema.statics.getChildren = async function (topicId: string) {
  return this.find({ parentId: topicId, isDeleted: { $ne: true } });
};

/**
 * Get entire subtree
 * NEW: Single regex query with materialized path!
 */
topicSchema.statics.getSubtree = async function (path: string) {
  return this.find({ 
    path: new RegExp(`^${path.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`),
    isDeleted: { $ne: true }
  });
};

export const Topic = model<ITopicDocument, TopicModel>(
  "Topic",
  topicSchema,
  "topics"
);
